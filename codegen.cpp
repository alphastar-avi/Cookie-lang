#include <map>
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Verifier.h"
#include "llvm/IR/Type.h"
#include "llvm/IR/Constants.h"
#include "ast.h"
#include <iostream>
#include <cstring>
#include <cstdlib>

// Ensure C linkage for yyparse (generated by Bison)
extern "C" int yyparse();

// LLVM globals
using namespace llvm;
LLVMContext Context;
Module *TheModule = new Module("GoofyLang", Context);
IRBuilder<> Builder(Context);
std::map<std::string, Value*> NamedValues;

// Declare the AST root generated by the parser
extern ASTNode* root;

// Forward declaration for AST printing
extern void printAST(ASTNode* node, int level);

Value *generateIR(ASTNode *node) {
    if (!node) return nullptr;

    if (strcmp(node->type, "NUMBER") == 0) {
        return ConstantInt::get(Type::getInt32Ty(Context), atoi(node->value));
    }
    if (strcmp(node->type, "IDENTIFIER") == 0) {
        return NamedValues[node->value];
    }
    if (strcmp(node->type, "ADD") == 0) {
        return Builder.CreateAdd(generateIR(node->left), generateIR(node->right), "addtmp");
    }
    if (strcmp(node->type, "SUB") == 0) {
        return Builder.CreateSub(generateIR(node->left), generateIR(node->right), "subtmp");
    }
    if (strcmp(node->type, "MUL") == 0) {
        return Builder.CreateMul(generateIR(node->left), generateIR(node->right), "multmp");
    }
    if (strcmp(node->type, "DIV") == 0) {
        return Builder.CreateSDiv(generateIR(node->left), generateIR(node->right), "divtmp");
    }
    if (strcmp(node->type, "ASSIGN") == 0) {
        Value *val = generateIR(node->left);
        NamedValues[node->value] = val;
        return val;
    }
    if (strcmp(node->type, "PRINT") == 0) {
        Value *val = generateIR(node->left);
        // Print at compile time; later you could generate runtime print calls.
        std::cout << "Print: " << node->left->value << std::endl;
        return val;
    }
    if (strcmp(node->type, "LOOP") == 0) {
        // Unroll loop for a constant count.
        int count = atoi(node->value);
        Value* lastVal = nullptr;
        for (int i = 0; i < count; i++) {
            lastVal = generateIR(node->left);
        }
        return lastVal;
    }
    if (strcmp(node->type, "STATEMENT_LIST") == 0) {
        // Process left and right statements sequentially.
        Value* leftVal = generateIR(node->left);
        Value* rightVal = generateIR(node->right);
        return rightVal; // Return value of the last statement.
    }
    return nullptr;
}

int main() {
    // Parse input and build the AST.
    if (yyparse() != 0) {
        std::cerr << "Parsing failed." << std::endl;
        return 1;
    }

    // Debug: Print the AST.
    std::cout << "AST:" << std::endl;
    printAST(root, 0);
    
    // Create main function (i32 return type).
    FunctionType *funcType = FunctionType::get(Type::getInt32Ty(Context), false);
    Function *mainFunc = Function::Create(funcType, Function::ExternalLinkage, "main", TheModule);
    BasicBlock *BB = BasicBlock::Create(Context, "entry", mainFunc);
    Builder.SetInsertPoint(BB);

    // Generate IR from the AST.
    Value *result = generateIR(root);
    if (!result) {
        result = ConstantInt::get(Type::getInt32Ty(Context), 0);
    }
    Builder.CreateRet(result);

    // Verify the module.
    std::string error;
    raw_string_ostream errorStream(error);
    if (verifyModule(*TheModule, &errorStream)) {
        std::cerr << "Error constructing module: " << errorStream.str() << std::endl;
        return 1;
    }

    // Print generated LLVM IR.
    TheModule->print(outs(), nullptr);

    delete TheModule;
    return 0;
}
